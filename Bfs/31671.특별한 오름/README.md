# [특별한 오름](https://www.acmicpc.net/problem/31671)

## input
첫 번째 줄에 오름의 높이 N과 선생님이 계시는 지점의 개수 
M이 공백을 사이에 두고 주어진다.

두 번째 줄부터 M+1번째 줄까지 선생님의 x좌표 x_i와 
y좌표 y_i가 공백으로 구분되어 주어진다. 선생님은 항상 오름의 내부 혹은 경계에 있다.

## output
첫 번째 줄에 찍을 수 있는 사진의 아름다움의 최댓값을 출력한다. 단, 시작 지점에서 도착 지점까지 이동할 수 없는 경우에는 -1을 출력한다.

## constraints
1<=N<=1000
1<=M<=min((n+1)(n+2)/2-1, 100000)
0<=x_i<=2N
0<=y_i<=N
x_i + y_i 는 짝수다
(0,0)에는 선생님이 계시지 않는다.

## precode
1. `N`(오름의 높이)과 `M`(선생님이 계시는 지점의 수)을 입력받습니다.
- **`N x 2N` 크기의 2차원 배열**을 생성합니다.
   - BFS로 이동 가능한 경로만 탐색하므로 삼각형으로 배열을 만들 필요는 없습니다.
- 장애물(선생님)의 좌표를 입력받아 해당 위치를 `-1`로 저장합니다.
2. 두 번의 BFS를 실행합니다
- 첫 번째 BFS: 출발점 (0,0)에서 시작해 도착 가능한 모든 위치를 탐색하며, 각 위치까지의 높이 y의 최대값을 기록합니다.
- 단방향 BFS는 중간에 막혀 도달하지 못할 경우의 상황을 정확히 알 수 없습니다.
- 양쪽에서 BFS를 수행해 만나는 지점의 최대 높이를 찾으면, 양쪽 방향 모두 유효한 경로임을 보장할 수 있습니다.
두 방향에서 탐색을 수행해야 경로가 실제로 존재하는지 확인할 수 있습니다.
- 두 번째 BFS: 도착점 (2N,0)에서 출발해서 반대 방향으로 탐색합니다.이 BFS는 교차 가능한 경로를 확인하는 역할을 합니다 즉, 출발 BFS와 도착 BFS가 만나는 지점의 최대 y 값을 찾습니다.
3. 이동 조건
- 다음 위치의 `Y` 좌표는 특정 조건을 만족해야 합니다:
   - **왼쪽 영역** (`X <= N`): `0 <= Y <= X`
   - **오른쪽 영역** (`X > N`): `0 <= Y <= (2N - X)`
- 배열의 범위를 벗어나면 안 됩니다: `0 <= X <= 2N`, `0 <= Y <= N`
- 이미 방문한 위치 또는 장애물(`-1`)인 위치는 건너뜁니다.

4. 결과 계산
- BFS 탐색 결과를 저장한 두 개의 방문 배열(`Visited1`과 `Visited2`)을 비교합니다.
- 두 BFS 모두 방문한 지점 중 **`Y` 좌표의 최댓값**을 찾습니다.
- 도착점 `(0, 2N)`과 `(0, 0)`에 각각 도달했는지 확인합니다.
  - 도달했으면 최댓값을 출력합니다.
  - 도달하지 못하면 `-1`을 출력합니다.

5. 출력
- 이동할 수 있는 경우 **`Y` 좌표의 최댓값**을 출력합니다.
- 이동할 수 없는 경우 `-1`을 출력합니다.

* 자료구조
    - list
        - 2차원 배열
* 알고리즘
    - BFS

* 참고자료
    