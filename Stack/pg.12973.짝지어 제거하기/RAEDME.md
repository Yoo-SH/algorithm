# 📝 알고리즘 문제 풀이 설계 양식

## 1. 문제 정보

* **문제 이름/번호:** 짝지어 제거하기 (PGS 12973)
* **문제 링크:** [링크](https://school.programmers.co.kr/learn/courses/30/lessons/12973)
* **핵심 요구사항:** 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성
* **제약조건:** 
    - 문자열의 길이 : 1,000,000이하의 자연수
    - 문자열은 모두 소문자로 이루어져 있습니다.



---

## 2. 입출력 정리

* **Input:**
    - 문자열 s
* **Output:**
    - 짝지어 제거하기를 성공적으로 수행할 수 있는지 여부 (True->1/False->0)

---

## 3. 아이디어 구상

- 스택을 이용하여, 순환하며 스택에 없는 문자는 push하고, 있는 문자는 pop하여 매칭시킨다.
---

## 4. 접근 방법

* **자료구조:** 스택 (list)
* **알고리즘/패러다임:** Greedy
* **접근 이유:** 스택을 이용한 짝지어 제거하기는 직관적이고 효율적이기 때문

---

## 5. 풀이 절차 (precode)

1. 빈 스택 생성
2. 문자열 s의 각 문자에 대해 반복
   1. 스택이 비어있거나, 스택의 최상단 문자와 현재 문자가 다르면 스택에 현재 문자 push
   2. 스택의 최상단 문자와 현재 문자가 같으면 스택에서 최상단 문자 pop
3. 반복 종료 후 스택이 비어있으면 1 반환, 값이 있으면 0 반환

---

## 6. 예제 확인

* **주어진 예제:** 직접 손으로 풀어서 풀이 검증
* **엣지 케이스:** 
    - 문자열이 하나인 경우
    - 모든 문자가 같은 경우
    - 짝지어 제거하기가 불가능한 경우 (예: "abc")
    - 짝지어 제거하기가 가능한 경우 (예: "aabbcc")
    - 짝지어 제거하기가 가능한 경우 (예: "abccba")

---

## 7. 시간/공간 복잡도 분석

* 시간 복잡도:
* 공간 복잡도:

---

## 8. 구현 시 주의할 점

* 인덱스 / off-by-one
* 자료형 범위 (int vs long long)
* 입력 크기 때문에 `sys.stdin.readline` 같은 fast I/O 필요 여부

---

## 9. 코드 작성

```python
def solution(s):

    stack = []

    
    for c in s:
        if  (len(stack) == 0) or (c != stack[-1]): #현재 데이터가 스택에 없거나 stack에 아무런 데이터가 없다면
            stack.append(c)
        else:
            stack_top = stack[-1]
            if stack_top == c: # 스택 최상단 문자와 현재 문자가 같다면
                stack.pop()

    if stack: # 엣지 케이스(문자열 홀수개인 경우, 매칭되는게 없는경우)
        return 0
    
    return 1    
```

---

## 10. AI 피드백
좋습니다 👍 코드가 전반적으로 문제 의도를 잘 반영하고 있어요. 스택을 이용해서 인접한 짝을 제거하는 방식은 시간복잡도 O(n)으로 최적입니다.
아래 피드백을 드릴게요.

---

### 1. 잘한 점 ✅

* **스택 활용**: 인접한 두 문자가 같으면 제거 → 이 문제의 정석 풀이입니다.
* **시간복잡도 최적**: 문자열 길이가 최대 100만이므로 O(n) 풀이가 필요합니다. for문 1번과 스택 push/pop만 사용 → 효율적입니다.
* **명확한 조건 분기**: `if (len(stack) == 0) or (c != stack[-1])` 조건으로 직관적 처리.
* **엣지 케이스 고려**: 문자열이 끝났을 때 스택이 비었는지 확인 → 결과 리턴 정확.

---

### 2. 개선할 점 ⚡

* **불필요한 변수**: `stack_top = stack[-1]`은 필요 없습니다. 이미 위에서 `c != stack[-1]`을 확인했으므로, else 블록 안에서는 `stack.pop()`만 하면 됩니다.
* **가독성 개선**: `if len(stack) == 0` 대신 `if not stack`이 더 파이썬스럽습니다.
* **주석 다듬기**: 설명이 길고 중복된 부분이 있음 → 간결하게 줄이면 코드 가독성이 올라갑니다.
* **리턴문 단순화**: 마지막에 `if stack: return 0 else: return 1` 대신 `return 0 if stack else 1` 한 줄로 표현 가능.

---

### 3. 개선된 버전 예시 ✨

```python
def solution(s):
    stack = []
    
    for c in s:
        if stack and stack[-1] == c:  # 스택 최상단과 같으면 제거
            stack.pop()
        else:  # 아니면 push
            stack.append(c)
    
    return 0 if stack else 1
```

### 장점

* 코드가 더 **간결**하고 **파이썬답게 표현**됨.
* 불필요한 변수(`stack_top`) 제거 → 깔끔.
* 핵심 로직이 바로 보임 → 가독성 향상.

---


## 11. 힌트

1. 첫 번째 힌트: 문제 분석 방향
   문자열에서 **인접한 같은 문자 쌍을 만나면 그 둘을 삭제**하는 과정을 반복하는 문제예요. 이걸 매번 문자열 전체를 뒤져가며 삭제하면 비효율적이므로, 왼쪽에서 오른쪽으로 한 번만 순회하면서 현재까지 남아있는 문자열 상태를 “갱신”해 나가는 관점으로 생각하세요 — 만약 새로 본 문자가 바로 앞에 남아있는 문자와 짝을 이룬다면 둘을 없애고, 아니면 남겨두는 식으로요.

2. 두 번째 힌트: 적합한 알고리즘/자료구조 유형
   위의 '앞부분(마지막에 남아있는 문자)과만 비교해서 취소/유지' 패턴은 **스택(LIFO)** 으로 자연스럽게 구현됩니다. 각 문자를 순회하며 스택의 최상단(top)과 비교하고 같으면 pop(짝 제거), 다르면 push(남김). 이 방식은 한 번의 선형 순회로 처리되므로 시간복잡도 **O(n)**, 추가 공간은 최악의 경우 O(n)입니다. 반면, 문자열 치환이나 전체 검색을 반복하면 최악의 시간복잡도가 크게 늘어납니다.

3. 세 번째 힌트: 구현 시 주의사항
   구현에서 흔히 하는 실수와 성능 함정에 주의하세요. 특히 Python에서 `if c in stack`처럼 스택 전체를 검사하면 연산이 O(n)이고 전체 루프와 결합되면 O(n²)이 되어 큰 입력(최대 1,000,000)에서 TLE나 메모리 문제를 일으킵니다. 또한 “최상단 문자와의 비교”는 스택이 비어있는지 먼저 확인한 뒤에만 해야 하고, 비교 결과가 다르면 **즉시 0을 반환하지 말고** 현재 문자를 스택에 남겨야 합니다. 최종적으로 모든 문자를 처리한 뒤 스택이 비어있으면 성공(1), 아니면 실패(0)라는 점도 잊지 마세요.
