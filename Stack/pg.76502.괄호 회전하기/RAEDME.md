# ğŸ“ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ ì„¤ê³„ ì–‘ì‹

## 1. ë¬¸ì œ ì •ë³´

* **ë¬¸ì œ ì´ë¦„/ë²ˆí˜¸:** ê´„í˜¸ íšŒì „í•˜ê¸° (PGS 76502)
* **ë¬¸ì œ ë§í¬:** [ë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/76502)
* **í•µì‹¬ ìš”êµ¬ì‚¬í•­:** ì£¼ì–´ì§„ ê´„í˜¸ ë¬¸ìì—´ì´ ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ì¸ì§€ íŒë³„
* **ì œì•½ì¡°ê±´:** ë¬¸ìì—´ ê¸¸ì´ 1 â‰¤ s â‰¤ 1,000

---

## 2. ì…ì¶œë ¥ ì •ë¦¬

* **Input:**
    - ë¬¸ìì—´ s
* **Output:**
    - sê°€ ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ì´ ë˜ê²Œ í•˜ëŠ” xì˜ ê°œìˆ˜

---

## 3. ì•„ì´ë””ì–´ êµ¬ìƒ

* ë¬¸ìì—´ së¥¼ xë§Œí¼ íšŒì „ì‹œí‚¨ë‹¤.
* íšŒì „ëœ ë¬¸ìì—´ì´ ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ì¸ì§€ í™•ì¸í•œë‹¤.
    - ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ì¸ì§€ í™•ì¸í•˜ëŠ” ë°©ë²•
        - ìŠ¤íƒ ìë£Œêµ¬ì¡°ë¥¼ í™œìš©
        - ì—¬ëŠ” ê´„í˜¸ë¥¼ ë§Œë‚˜ë©´ ìŠ¤íƒì— push
        - ë‹«ëŠ” ê´„í˜¸ë¥¼ ë§Œë‚˜ë©´ ìŠ¤íƒì—ì„œ pop í•˜ì—¬ ë§¤ì¹­
            - ë§¤ì¹­ ë˜ì§€ ì•Šìœ¼ë©´ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ë¬¸ìì—´
        - ìŠ¤íƒì´ ë¹„ì–´ìˆëŠ”ë° ë‹«ëŠ” ê´„í˜¸ê°€ ë‚˜ì˜¤ë©´ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ë¬¸ìì—´
        - ëª¨ë“  ë¬¸ìë¥¼ ë‹¤ ì²˜ë¦¬í•œ í›„ ìŠ¤íƒì´ ë¹„ì–´ìˆìœ¼ë©´ ì˜¬ë°”ë¥¸ ë¬¸ìì—´
* xë¥¼ 0ë¶€í„° len(s)-1ê¹Œì§€ ë³€í™”ì‹œí‚¤ë©° ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ì¸ì§€ í™•ì¸


---

## 4. ì ‘ê·¼ ë°©ë²•

* **ìë£Œêµ¬ì¡°:** Stack (list í™œìš©)
* **ì•Œê³ ë¦¬ì¦˜/íŒ¨ëŸ¬ë‹¤ì„:** 
* **ì ‘ê·¼ ì´ìœ :** ìŠ¤íƒì„ í™œìš©í•œ ê´„í˜¸ ë§¤ì¹­ì´ ì§ê´€ì ì´ê³  íš¨ìœ¨ì ì´ê¸° ë•Œë¬¸ FILO êµ¬ì¡°ë¡œ ì—¬ëŠ” ê´„í˜¸ë¥¼ ì €ì¥í•˜ê³  ë‹«ëŠ” ê´„í˜¸ê°€ ë‚˜ì˜¬ ë•Œ ë§¤ì¹­í•˜ëŠ” ë°©ì‹ì´ ì í•©.

---

## 5. í’€ì´ ì ˆì°¨ (precode)

1. ì…ë ¥ ì²˜ë¦¬
    - ë¬¸ìì—´ së¥¼ ì…ë ¥ë°›ëŠ”ë‹¤.
2. ì£¼ìš” ë°ì´í„° êµ¬ì¡° ì„¸íŒ…
    - ìŠ¤íƒì„ ì´ˆê¸°í™”í•œë‹¤.
3. í•µì‹¬ ë¡œì§ ìˆœì„œë„
    - ë¬¸ìì—´ së¥¼ xë§Œí¼ íšŒì „ì‹œí‚¨ë‹¤.
    - íšŒì „ëœ ë¬¸ìì—´ì´ ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ì¸ì§€ í™•ì¸í•œë‹¤.
        - ì—¬ëŠ” ê´„í˜¸ë¥¼ ë§Œë‚˜ë©´ ìŠ¤íƒì— push
        - ë‹«ëŠ” ê´„í˜¸ë¥¼ ë§Œë‚˜ë©´ ìŠ¤íƒì—ì„œ pop í•˜ì—¬ ë§¤ì¹­
            - ë§¤ì¹­ ë˜ì§€ ì•Šìœ¼ë©´ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ë¬¸ìì—´
        - ìŠ¤íƒì´ ë¹„ì–´ìˆëŠ”ë° ë‹«ëŠ” ê´„í˜¸ê°€ ë‚˜ì˜¤ë©´ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ë¬¸ìì—´
        - ëª¨ë“  ë¬¸ìë¥¼ ë‹¤ ì²˜ë¦¬í•œ í›„ ìŠ¤íƒì´ ë¹„ì–´ìˆìœ¼ë©´ ì˜¬ë°”ë¥¸ ë¬¸ìì—´
4. ì¢…ë£Œ ì¡°ê±´ ë° ê²°ê³¼ ë°˜í™˜
    - xë¥¼ 0ë¶€í„° len(s)-1ê¹Œì§€ ë³€í™”ì‹œí‚¤ë©° ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ì¸ì§€ í™•ì¸
    - ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ì´ ë˜ëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ë°˜í™˜

---

## 6. ì˜ˆì œ í™•ì¸

* **ì£¼ì–´ì§„ ì˜ˆì œ:** ì§ì ‘ ì†ìœ¼ë¡œ í’€ì–´ì„œ í’€ì´ ê²€ì¦
* **ì—£ì§€ ì¼€ì´ìŠ¤:** ìµœì†Œ ì…ë ¥ / ìµœëŒ€ ì…ë ¥ / íŠ¹ìˆ˜ ìƒí™©

---

## 7. ì‹œê°„/ê³µê°„ ë³µì¡ë„ ë¶„ì„

* ì‹œê°„ ë³µì¡ë„:
* ê³µê°„ ë³µì¡ë„:

---

## 8. êµ¬í˜„ ì‹œ ì£¼ì˜í•  ì 

---

## 9. ì½”ë“œ ì‘ì„±

```Python
def check_is_matched(s:str):
    stack_for_parentheses = []

    for c in s:
        if c in "{([":
            stack_for_parentheses.append(c)
        elif c == "}":
            try:
                pop_c = stack_for_parentheses.pop()
                if pop_c != "{":
                    return False
            except IndexError:
                return False
        elif c == ")":
            try:
                pop_c = stack_for_parentheses.pop()
                if pop_c != "(":
                    return False
            except IndexError:
                return False
        elif c == "]":
            try:
                pop_c = stack_for_parentheses.pop()
                if pop_c != "[":
                    return False
            except IndexError:
                return False
    
    # ëª¨ë“  ë¬¸ìë¥¼ ë‹¤ ì²˜ë¦¬í•œ í›„ ìŠ¤íƒì´ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
    if stack_for_parentheses:
        return False
    else:
        return True
            
    

def rotate_to_right(s:str, x: int):
    # ì˜¤ë¥¸ìª½ìœ¼ë¡œ xì¹¸ì”© ì´ë™
    s = s[-x:] + s[:-x]
    return s

def solution(s):

    count_is_matched = 0                    

    # íšŒì „ì‹œí‚¤ë©´ì„œ ë¬¸ìì—´ì´ ë§ëŠ”ì§€ í™•ì¸
    for x in range(0,len(s)):
        if check_is_matched(rotate_to_right(s,x)):
            count_is_matched += 1
        
        
    return count_is_matched
```

## 10. AI í”¼ë“œë°±

### âœ… ì˜í•œ ì 

1. **ìŠ¤íƒ í™œìš©**
   ê´„í˜¸ ì§ ê²€ì‚¬ë¥¼ ì „í˜•ì ì¸ ë°©ì‹ì¸ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„í•˜ì—¬ ê°€ë…ì„±ê³¼ ì§ê´€ì„±ì´ ë†’ìŠµë‹ˆë‹¤.

2. **ì˜ˆì™¸ ì²˜ë¦¬**
   `IndexError` ì˜ˆì™¸ë¥¼ í™œìš©í•˜ì—¬ ìŠ¤íƒì´ ë¹„ì—ˆì„ ë•Œ ì˜ëª»ëœ ê´„í˜¸ êµ¬ì¡°ì„ì„ ë°”ë¡œ íŒë³„í•˜ëŠ” ì ì´ ì•ˆì •ì ì…ë‹ˆë‹¤.

3. **ì½”ë“œ ë¶„ë¦¬**

   * `check_is_matched` : ê´„í˜¸ ìœ íš¨ì„± ê²€ì‚¬
   * `rotate_to_right` : ë¬¸ìì—´ íšŒì „
   * `solution` : ì „ì²´ íë¦„ ì œì–´
     í•¨ìˆ˜ ë¶„ë¦¬ë¡œ ì¸í•´ ì½”ë“œ êµ¬ì¡°ê°€ ëª…í™•í•˜ê³  ìœ ì§€ë³´ìˆ˜ê°€ ìš©ì´í•©ë‹ˆë‹¤.

4. **ìµœì¢… ê²€ì¦**
   ëª¨ë“  ë¬¸ìë¥¼ ì²˜ë¦¬í•œ í›„ ìŠ¤íƒì´ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë¶€ë¶„(`if stack_for_parentheses:`)ì´ í¬í•¨ë˜ì–´ ìˆì–´ ë…¼ë¦¬ì  ì™„ê²°ì„±ì´ ìˆìŠµë‹ˆë‹¤.

---

### âš ï¸ ê°œì„ í•  ì 

1. **ì¤‘ë³µ ì½”ë“œ ì œê±°**
   `check_is_matched` í•¨ìˆ˜ì—ì„œ `}`, `)`, `]` ì²˜ë¦¬ ë¡œì§ì´ ìœ ì‚¬í•˜ê²Œ ë°˜ë³µë˜ê³  ìˆìŠµë‹ˆë‹¤.
   â†’ `dict` ë§¤í•‘ì„ ì‚¬ìš©í•˜ë©´ ì¤‘ë³µì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

   ```python
   pairs = {")": "(", "}": "{", "]": "["}
   if c in pairs:
       if not stack_for_parentheses or stack_for_parentheses.pop() != pairs[c]:
           return False
   ```

2. **ë¬¸ìì—´ íšŒì „ ìµœì í™”**
   `rotate_to_right` í•¨ìˆ˜ëŠ” ë¬¸ìì—´ ìŠ¬ë¼ì´ì‹±ì„ ë§¤ë²ˆ ìƒˆë¡œ ìˆ˜í–‰í•©ë‹ˆë‹¤.

   * ê¸¸ì´ê°€ `n`ì¸ ë¬¸ìì—´ì— ëŒ€í•´ `n`ë²ˆ íšŒì „í•˜ë¯€ë¡œ O(nÂ²) ë³µì¡ë„ê°€ ë°œìƒí•©ë‹ˆë‹¤.
   * ì‹¤ì œë¡œëŠ” **ì™¼ìª½ íšŒì „**ë§Œ í•´ë„ ì¶©ë¶„í•©ë‹ˆë‹¤. (ì˜ˆ: ì˜¤ë¥¸ìª½ 1ì¹¸ íšŒì „ = ì™¼ìª½ (n-1)ì¹¸ íšŒì „)
   * ë˜ëŠ” `collections.deque`ì˜ `rotate()`ë¥¼ í™œìš©í•˜ë©´ ì„±ëŠ¥ì´ ê°œì„ ë©ë‹ˆë‹¤.

3. **í•¨ìˆ˜ëª… ê°œì„ **

   * `check_is_matched` â†’ `is_balanced_parentheses`
   * `rotate_to_right` â†’ `rotate_string_right`
     ì¡°ê¸ˆ ë” ì§ê´€ì ì¸ ì´ë¦„ìœ¼ë¡œ ë°”ê¾¸ë©´ ë‹¤ë¥¸ ê°œë°œìë„ ì´í•´í•˜ê¸° ì‰¬ì›Œì§‘ë‹ˆë‹¤.

4. **í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ í•„ìš”**
   ë‹¤ì–‘í•œ ì…ë ¥ê°’(`"()[]{}"`, `"([)]"`, `""`, `")("`)ì— ëŒ€í•œ ìœ ë‹› í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ì¶”ê°€ë˜ë©´ ë” ê²¬ê³ í•œ í’€ì´ê°€ ë©ë‹ˆë‹¤.

---

### ğŸŒŸ ê°œì„ ëœ ë²„ì „ ì˜ˆì‹œ

```python
def is_balanced_parentheses(s: str) -> bool:
    stack = []
    pairs = {")": "(", "}": "{", "]": "["}

    for c in s:
        if c in pairs.values():
            stack.append(c)
        elif c in pairs:
            if not stack or stack.pop() != pairs[c]:
                return False
    return not stack


from collections import deque

def solution(s: str) -> int:
    dq = deque(s)
    count = 0

    for _ in range(len(s)):
        if is_balanced_parentheses("".join(dq)):
            count += 1
        dq.rotate(-1)  # ì™¼ìª½ìœ¼ë¡œ 1ì¹¸ íšŒì „
    return count
```

---

ğŸ‘‰ ìš”ì•½í•˜ë©´, **í˜„ì¬ ì½”ë“œë„ ë¬¸ì œ í•´ê²°ì—ëŠ” ì¶©ë¶„íˆ ì˜¬ë°”ë¥´ì§€ë§Œ, ì¤‘ë³µ ì œê±° / íš¨ìœ¨ì„± ê°œì„  / í•¨ìˆ˜ëª… ëª…í™•í™” / í…ŒìŠ¤íŠ¸ ë³´ê°•**ì„ í•˜ë©´ ë” ê¹”ë”í•˜ê³  í™•ì¥ ê°€ëŠ¥í•œ ì½”ë“œê°€ ë©ë‹ˆë‹¤.