# 📝 알고리즘 문제 풀이 설계 양식

## 1. 문제 정보

* **문제 이름/번호:** 다단계 칫솔 판매
* **문제 링크:** https://school.programmers.co.kr/learn/courses/30/lessons/77486
* **핵심 요구사항:**: 다단계 판매 구조에서 각 판매원이 얻는 수익을 계산
* **제약조건:**
- enroll의 길이는 1 이상 10,000 이하입니다.
    - enroll에 민호의 이름은 없습니다. 따라서 enroll의 길이는 민호를 제외한 조직 구성원의 총 수입니다.
    - referral의 길이는 enroll의 길이와 같습니다.
- referral 내에서 i 번째에 있는 이름은 배열 enroll 내에서 i 번째에 있는 판매원을 조직에 참여시킨 사람의 이름입니다.
    - 어느 누구의 추천도 없이 조직에 참여한 사람에 대해서는 referral 배열 내에 추천인의 이름이 기입되지 않고 “-“ 가 기입됩니다. 위 예제에서는 john 과 mary 가 이러한 예에 해당합니다.
    - enroll 에 등장하는 이름은 조직에 참여한 순서에 따릅니다.
    - 즉, 어느 판매원의 이름이 enroll 의 i 번째에 등장한다면, 이 판매원을 조직에 참여시킨 사람의 이름, 즉 referral 의 i 번째 원소는 이미 배열 enroll 의 j 번째 (j < i) 에 등장했음이 보장됩니다.
- seller의 길이는 1 이상 100,000 이하입니다.
    - seller 내의 i 번째에 있는 이름은 i 번째 판매 집계 데이터가 어느 판매원에 의한 것인지를 나타냅니다.
    - seller 에는 같은 이름이 중복해서 들어있을 수 있습니다.
- amount의 길이는 seller의 길이와 같습니다.
    - amount 내의 i 번째에 있는 수는 i 번째 판매 집계 데이터의 판매량을 나타냅니다.
    - 판매량의 범위, 즉 amount 의 원소들의 범위는 1 이상 100 이하인 자연수입니다.
- 칫솔 한 개를 판매하여 얻어지는 이익은 100 원으로 정해져 있습니다.
- 모든 조직 구성원들의 이름은 10 글자 이내의 영문 알파벳 소문자들로만 이루어져 있습니다.

---

## 2. 입출력 정리

* **Input:** 
    - enroll: ["john", "mary", "edward", "sam", "emily", "jaimie", "tod", "young"]
    - referral: ["-", "-", "mary", "edward", "mary", "mary", "jaimie", "edward"]
    - seller: ["young", "john", "tod", "emily", "mary"]
    - amount: [12, 4, 2, 5, 10]
* **Output:**
    - [0, 100, 0, 300, 500, 0, 0, 0]
---

## 3. 아이디어 구상

* **핵심 아이디어:** 
    - 각 판매원이 얻는 수익을 계산하기 위해, 각 판매원의 부모(추천인)를 추적하는 트리 구조를 사용
    - 판매원이 물건을 팔 때마다, 그 수익의 10%를 부모에게 전달하고, 나머지 90%는 자신이 가짐
    - 이 과정을 재귀적으로 반복하여 최상위 부모까지 수익을 분배

---

## 4. 접근 방법

* **자료구조:**: 딕셔너리 (판매원과 그 부모를 매핑), 리스트 (각 판매원의 수익 저장)
* **알고리즘/패러다임:** DFS (Depth-First Search) 혹은 재귀
* **접근 이유:** 
    - 트리 구조에서 부모-자식 관계를 쉽게 탐색하고 수익을 분배하기 위해 재귀적 접근이 적합
    - 딕셔너리를 사용하여 각 판매원의 부모를 빠르게 조회 가능

---

## 5. 풀이 절차 (precode)

1. **입력 파싱:** enroll, referral, seller, amount를 입력받음
2. **트리 구조 생성:**
    - 딕셔너리를 사용하여 각 판매원과 그 부모를 매핑
    - 예: `parent = { "john": "-", "mary": "-", "edward": "mary", ... }`
3. **수익 초기화:** 각 판매원의 수익을 저장할 리스트 초기화
4. **수익 분배 함수 정의:**
    - 재귀 함수 `distribute_profit(seller, profit)` 정의
    - 함수 내부에서 현재 판매원의 수익을 계산하고, 10%를 부모에게 전달
    - 부모가 "-"인 경우 재귀 종료
5. **판매 데이터 처리:**
    - 각 판매원과 판매량에 대해 `distribute_profit` 함수 호출
6. **결과 반환:** 각 판매원의 최종 수익을 리스트로 반환

---

## 6. 예제 확인

* **주어진 예제:** 직접 손으로 풀어서 풀이 검증
* **엣지 케이스:** 10%를 계산한 금액이 1 원 미만인 경우에는 이득을 분배하지 않고 자신이 모두 가집니다.

---

## 7. 시간/공간 복잡도 분석

* 시간 복잡도:
* 공간 복잡도:

---

## 8. 구현 시 주의할 점

* 인덱스 / off-by-one
* 자료형 범위 (int vs long long)
* 입력 크기 때문에 `sys.stdin.readline` 같은 fast I/O 필요 여부

---

## 9. 코드 작성

```python
(여기에 실제 코드 작성)
```
---



## 10. AI 피드백

## 11. HINT

좋아요 👍
이 문제는 **“다단계 수익 분배”** 유형으로 보이네요.
요구하신 형식에 맞춰 **3단계 점진적 힌트**를 드릴게요.

---

### 💡 힌트

1. **문제 분석 방향:**

   * 각 판매자는 일정 수익을 얻고, 그 중 일부를 상위 추천인에게 전달하는 구조입니다.
   * 따라서, “누가 누구에게 수익을 주는가”를 계층적으로 추적해야 하며, **트리 형태의 관계**가 암묵적으로 존재합니다.

2. **적합한 알고리즘/자료구조 유형:**

   * **재귀(DFS) 또는 반복적 부모 추적 구조**를 사용해, 각 판매자의 수익을 위로 전달하는 방식이 적합합니다.
   * `dict`로 부모 관계를 저장하고, `defaultdict`로 수익을 누적 관리하면 구현이 간결해집니다.

3. **구현 시 주의사항:**

   * **소수점 처리**: 10%를 나눌 때 발생하는 부동소수점 오차를 주의해야 합니다.
   * **종료 조건**: 상위 노드가 `"-"`이거나, 분배 금액이 1원 미만일 경우 재귀를 종료해야 합니다.
   * **중복 갱신 방지**: 각 단계마다 자신의 몫과 부모에게 줄 금액을 정확히 구분해야 누락이나 과잉 분배가 없습니다.

---

원하신다면 이 코드의 **논리적 오류나 개선 포인트** 중심으로 피드백도 드릴 수 있어요. 그렇게 해드릴까요?
