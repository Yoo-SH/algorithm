# 📝 알고리즘 문제 풀이 설계 양식

## 1. 문제 정보

* **문제 이름/번호:** 예상 대진표
* **문제 링크:** https://school.programmers.co.kr/learn/courses/30/lessons/12985
* **핵심 요구사항:**: n명의 참가자가 토너먼트 방식으로 대진표를 짜고, 특정 두 참가자가 몇 라운드 만에 만나는지 계산
* **제약조건:**
- N : 21 이상 220 이하인 자연수 (2의 지수 승으로 주어지므로 부전승은 발생하지 않습니다.)
- A, B : N 이하인 자연수 (단, A ≠ B 입니다.)

---

## 2. 입출력 정리

* **Input:** n (참가자 수), a (참가자 A 번호), b (참가자 B 번호)
* **Output:** 두 참가자가 만나는 라운드 번호

---

## 3. 아이디어 구상

* **핵심 아이디어:** 
  - 각 라운드마다 참가자 번호를 반으로 나누어 업데이트
  - 두 참가자가 같은 번호가 될 때까지 반복
* **예시:**
  - n=8, a=4, b=7
  - 라운드 1: a=2, b=4
  - 라운드 2: a=1, b=2
  - 라운드 3: a=1, b=1 (만남)

---

## 4. 접근 방법

* **자료구조:**: 변수 (정수형)
* **알고리즘/패러다임:** 이진 탐색, 시뮬레이션
* **접근 이유:** 
  - 참가자 번호를 반으로 나누는 방식이 이진 탐색과 유사
  - 시뮬레이션을 통해 각 라운드마다 참가자 위치를 추적

---

## 5. 풀이 절차 (precode)

1. 라운드 카운터 초기화 (round = 0)
2. a와 b가 같아질 때까지 반복:
   - a와 b를 각각 (a + 1) // 2, (b + 1) // 2로 업데이트
   - 라운드 카운터 증가 (round += 1)
3. 라운드 카운터 반환

---

## 6. 예제 확인

* **주어진 예제:** 직접 손으로 풀어서 풀이 검증
* **엣지 케이스:** 최소 입력 / 최대 입력 / 특수 상황

---

## 7. 시간/공간 복잡도 분석

* 시간 복잡도: O(log n) - 각 라운드마다 참가자 수가 반으로 줄어들기 때문
* 공간 복잡도: O(1) - 추가적인 공간을 사용하지 않음

---

## 8. 구현 시 주의할 점

* 인덱스 / off-by-one
* 자료형 범위 (int vs long long)
* 입력 크기 때문에 `sys.stdin.readline` 같은 fast I/O 필요 여부

---

## 9. 코드 작성

```python
def solution(n,a,b):

    round =0
    
    while a != b:
        a = (a + 1) // 2
        b = (b + 1) // 2
        round +=1


    return round
```
---



## 10. AI 피드백

좋아요 👍 아래는 주어진 `solution` 코드에 대한 **구체적이고 건설적인 피드백**입니다.

---

### 1. 잘한 점 ✅

* **문제의 핵심 로직을 정확히 이해함**
  각 라운드마다 참가자의 번호를 `(번호 + 1) // 2`로 갱신하는 방식은 토너먼트의 구조를 매우 간결하게 표현한 올바른 접근입니다.
* **불필요한 자료구조 사용 없음**
  리스트나 큐 등을 사용하지 않고, 단순 변수 업데이트로 문제를 해결해 효율적입니다. (시간복잡도 O(log N))
* **명확한 종료 조건**
  `while a != b` 조건을 통해 두 참가자가 만날 때 루프를 종료하는 로직이 깔끔하게 작성되었습니다.

---

### 2. 개선할 점 ⚙️

* **변수명 개선 필요**
  `round`는 파이썬의 내장 함수(`round()`) 이름과 동일합니다. 변수명으로 사용하는 것은 피하는 것이 좋습니다. 예를 들어 `round_count` 또는 `stage`로 변경하면 명확하고 안전합니다.
* **가독성 향상**
  핵심 로직은 간단하지만, 주석을 추가하여 각 단계(예: 번호 업데이트, 라운드 증가)를 설명하면 읽는 사람이 이해하기 쉬워집니다.
* **함수 입력 검증(선택 사항)**
  실전 코딩테스트 환경에서는 불필요하지만, 학습 목적이라면 `a`와 `b`가 `1 ≤ a, b ≤ n` 범위 내인지 확인하는 코드도 좋은 습관입니다.

---

### 3. 개선한 버전 예시 💡

```python
def solution(n, a, b):
    """
    토너먼트 경기에서 참가자 A와 B가 몇 번째 라운드에서 만나는지 계산하는 함수.
    각 라운드마다 (번호 + 1) // 2 로 갱신되며, 두 번호가 같아지는 순간이 만나는 라운드이다.
    """
    round_count = 0  # 'round' 대신 내장함수 충돌 방지용 변수명 사용

    while a != b:
        # 다음 라운드의 번호는 현재 번호의 절반(홀수는 올림 처리)
        a = (a + 1) // 2
        b = (b + 1) // 2
        round_count += 1  # 라운드 증가

    return round_count
```

**💬 개선 포인트 요약:**

* `round` → `round_count`로 변경하여 가독성과 안정성 향상
* 간단한 설명 주석 추가로 코드 의도 명확히 표현
* 핵심 로직은 그대로 유지 (이미 최적의 O(log N) 구조)

---

📘 **추가 학습 팁:**
이 문제는 **이진 트리의 레벨(Level)** 개념과 동일합니다. 두 노드가 같은 부모를 갖게 되는 순간을 찾는 문제이므로, 트리 탐색 관점에서도 이해해보면 더 깊은 이해에 도움이 됩니다.
