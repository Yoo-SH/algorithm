# [장난감 조립](https://www.acmicpc.net/problem/2637)

## input
첫째 줄에는 자연수 N(3 ≤ N ≤ 100)이 주어지는데, 1부터 N-1까지는 기본 부품이나 중간 부품의 번호를 나타내고, N은 완제품의 번호를 나타낸다. 그리고 그 다음 줄에는 자연수 M(3 ≤ M ≤ 100)이 주어지고, 그 다음 M개의 줄에는 어떤 부품을 완성하는데 필요한 부품들 간의 관계가 3개의 자연수 X, Y, K로 주어진다. 이 뜻은 "중간 부품이나 완제품 X를 만드는데 중간 부품 혹은 기본 부품 Y가 K개 필요하다"는 뜻이다. 두 중간 부품이 서로를 필요로 하는 경우가 없다.

## output
하나의 완제품을 조립하는데 필요한 기본 부품의 수를 한 줄에 하나씩 출력하되(중간 부품은 출력하지 않음), 반드시 기본 부품의 번호가 작은 것부터 큰 순서가 되도록 한다. 각 줄에는 기본 부품의 번호와 소요 개수를 출력한다.  
정답은 2,147,483,647 이하이다.

---

## Precode
1. 그래프와 진입 차수 배열을 초기화하고, 조립 관계 데이터를 입력받아 그래프를 생성
2. 위상 정렬(Topological Sort)을 위해 각 노드의 진입 차수를 저장.
3. 위상 정렬 수행
    - 진입 차수가 0인 노드부터 시작하여 위상 정렬을 수행.
    - 각 노드에서 연결된 다음 노드로 필요한 부품 수를 전파.
4. 기본 부품 판별 및 출력
       - 기본 부품(`needs[i]`가 0인 경우)을 판별하여 필요한 개수를 출력.


* 자료구조
   - **그래프(Graph)**:
   - 각 부품의 조립 관계를 나타냄.
   - 방향성 있는 간선(`Y -> X`)과 가중치(`K`)로 구성된 그래프 사용.
   
    - **진입 차수(In-degree)**:

    -  **필요 부품 수 기록(2D Array)**:
   - `needs[i][j]`: `i`번 부품을 만들기 위해 필요한 기본 부품 `j`의 개수.

* 알고리즘
    - 위상정렬

* 시간 복잡도
1. **그래프 초기화**: O(M)
   - 입력 데이터(`M`)를 처리하여 그래프 생성.
   
2. **위상 정렬**: O(N + M)
   - N개의 노드와 M개의 간선을 탐색.
   
3. **필요 부품 계산**: O(N^2)
   - 각 노드마다 최대 N개의 기본 부품 정보를 누적.

총 시간 복잡도는 O(N^2 + M)으로, N과 M이 최대 100인 경우 충분히 효율적이다.

### 참고자료
- [위상 정렬(Topological Sort)](https://ko.wikipedia.org/wiki/%EC%9C%84%EC%83%81_%EC%A0%95%EB%A0%AC)
